<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
  <meta name="apple-mobile-web-app-capable" content="yes" />
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent" />
  <title>TilePad — Tile Shuffle Encode/Decode (WhatsApp‑robust)</title>
  <style>
    :root{
      --bg:#0b0f14; --card:#111827; --muted:#9aa4b2; --text:#e5ecf3; --acc:#7c3aed; --acc2:#22d3ee; --danger:#ef4444; --good:#22c55e;
      --ring:0 0 0 2px rgba(124,58,237,.45), 0 10px 30px rgba(124,58,237,.15);
      --tb: 96px; /* toolbar height fallback */
    }
    *{box-sizing:border-box}
    html,body{margin:0;height:100%;background:linear-gradient(180deg,#0b0f14, #0b0f14 40%, #0d1320 100%);color:var(--text);font-family:system-ui,-apple-system,Segoe UI,Roboto,Ubuntu,"Helvetica Neue",Arial,sans-serif;overflow-x:hidden}
    .app{min-height:100%;display:flex;flex-direction:column;}
    header{position:sticky;top:0;z-index:10;background:linear-gradient(180deg,rgba(13,19,32,.9),rgba(13,19,32,.6));backdrop-filter: blur(10px);padding: max(12px, env(safe-area-inset-top)) 16px 12px;border-bottom:1px solid rgba(255,255,255,.06);}    
    h1{margin:0;font-size:clamp(16px, 2.6vw, 20px);letter-spacing:.3px;display:flex;align-items:center;gap:10px;font-weight:700}
    h1 .dot{width:8px;height:8px;border-radius:999px;background:linear-gradient(135deg,var(--acc),var(--acc2));box-shadow:0 0 20px rgba(34,211,238,.65)}

    .stage{flex:1;display:flex;flex-direction:column;gap:12px;padding:12px 16px 0}
    .viewer{position:relative;background:radial-gradient(1200px 400px at 50% -200px, rgba(124,58,237,.15), transparent),
                          radial-gradient(600px 200px at 10% 0, rgba(34,211,238,.1), transparent),
                          var(--card);
            border:1px solid rgba(255,255,255,.06);border-radius:18px;overflow:hidden;box-shadow:0 10px 30px rgba(0,0,0,.3);
            min-height:320px; padding-bottom: calc(var(--tb) + 12px)}

    /* Responsive toolbar: auto-fit columns; wraps as needed; safe-area aware */
    .viewer .toolbar{position:absolute;left:8px;right:8px;bottom:8px;display:grid;gap:8px;
      grid-template-columns: repeat(auto-fit, minmax(110px, 1fr));
      max-width: calc(100% - env(safe-area-inset-left) - env(safe-area-inset-right) - 16px);
      padding-bottom: env(safe-area-inset-bottom)}

    .btn{appearance:none;border:none;border-radius:14px;padding:clamp(8px,1.8vw,12px) clamp(8px,1.6vw,12px);font-weight:700;color:var(--text);
         background:linear-gradient(180deg,#1a2435,#141c2b);border:1px solid rgba(255,255,255,.08);
         box-shadow:0 6px 18px rgba(0,0,0,.25);display:flex;align-items:center;justify-content:center;gap:8px;
         transition:transform .06s ease, box-shadow .2s ease;touch-action:manipulation;font-size:clamp(12px,2.8vw,14px)}
    .btn:active{transform:translateY(1px)}
    .btn.primary{background:linear-gradient(180deg,#2a3754,#1b2538);border-color:rgba(124,58,237,.45);box-shadow:var(--ring)}
    .btn.danger{background:linear-gradient(180deg,#3a1f25,#2a1417);border-color:rgba(239,68,68,.4);}
    .btn.good{background:linear-gradient(180deg,#193323,#13281b);border-color:rgba(34,197,94,.4);}
    .btn[disabled]{opacity:.5;filter:saturate(.5);pointer-events:none}
    .btn .ico{width:clamp(14px,2.6vw,18px);height:clamp(14px,2.6vw,18px);opacity:.9}

    canvas{display:block;width:100%;height:auto;max-height:62vh;object-fit:contain;background:
      repeating-conic-gradient(from 45deg, rgba(255,255,255,.05) 0 10deg, transparent 10deg 20deg) center/40px 40px}

    .meta{display:flex;align-items:center;gap:10px;padding:8px 2px 12px;flex-wrap:wrap}
    .meta .chip{font-size:12px;color:var(--muted);background:rgba(255,255,255,.05);padding:6px 10px;border-radius:999px;border:1px solid rgba(255,255,255,.06)}

    .footer{position:sticky;bottom:0;z-index:10;background:linear-gradient(0deg,rgba(13,19,32,.9),rgba(13,19,32,.6));
            backdrop-filter: blur(10px); padding:12px 16px max(12px, env(safe-area-inset-bottom)); border-top:1px solid rgba(255,255,255,.06)}

    .sr-only{position:absolute;width:1px;height:1px;padding:0;margin:-1px;overflow:hidden;clip:rect(0,0,0,0);white-space:nowrap;border:0}

    .toast{position:fixed;left:50%;bottom:calc(16px + env(safe-area-inset-bottom));transform:translateX(-50%);
           background:#0b1220;color:var(--text);border:1px solid rgba(255,255,255,.1);border-radius:12px;
           padding:10px 14px;font-size:14px;box-shadow:0 10px 30px rgba(0,0,0,.35);opacity:0;pointer-events:none;transition:opacity .25s ease;max-width:90%;text-align:center}
    .toast.show{opacity:1}

    @media (min-width: 560px){ canvas{max-height:70vh} }
  </style>
</head>
<body>
<div class="app">
  <header>
    <h1><span class="dot"></span> TilePad <span style="color:var(--muted);font-weight:600">· Tile Shuffle</span></h1>
  </header>

  <main class="stage" role="main">
    <section class="viewer" aria-label="Image viewer">
      <canvas id="canvas" aria-label="Image canvas" width="640" height="360"></canvas>
      <div id="placeholder" style="position:absolute;inset:0;display:flex;align-items:center;justify-content:center;color:var(--muted);font-weight:600;letter-spacing:.2px;pointer-events:none">Tap <em style='color:var(--text);font-style:normal'>Upload</em> to start</div>
      <div class="toolbar" id="toolbar">
        <button id="btnUpload" class="btn primary" title="Upload image">Upload</button>
        <button id="btnEncode" class="btn" title="Encode (shuffle tiles)">Encode</button>
        <button id="btnDecode" class="btn" title="Decode (unshuffle)">Decode</button>
        <button id="btnShare" class="btn good" title="Share current image">Share</button>
        <button id="btnReset" class="btn danger" title="Reset">Reset</button>
      </div>
      <input id="file" type="file" accept="image/*" class="sr-only" />
    </section>

    <div class="meta">
      <span id="status" class="chip">No image loaded</span>
      <span id="dim" class="chip">–</span>
      <label class="chip" style="display:flex;align-items:center;gap:8px">
        <input id="normalize" type="checkbox" checked /> Normalize for WhatsApp
      </label>
      <button id="btnTests" class="btn" style="margin-left:auto">Run Self‑Test</button>
    </div>
  </main>

  <footer class="footer">
    <div style="font-size:12px;color:var(--muted);line-height:1.4">
      Encode shuffles/rotates tiles so it remains decodable even after WhatsApp photo compression. Normalization ensures consistent size.
    </div>
  </footer>
</div>

<div id="toast" class="toast" role="status" aria-live="polite"></div>

<script>
(() => {
  'use strict';
  // --- Fixed parameters (keep consistent across devices) ---
  const TILE = 32;              // tile size in pixels
  const LONG_EDGE = 1280;       // target long edge for WhatsApp normalization
  const SEED = 0x41C0FFEE;      // deterministic PRNG seed

  // xorshift32 PRNG
  function* prng(seed){
    let x = seed >>> 0;
    while (true){ x ^= x << 13; x >>>= 0; x ^= x >>> 17; x >>>= 0; x ^= x << 5; x >>>= 0; yield x >>> 0; }
  }

  // Deterministic permutation & orientation from grid size
  function makePlan(cols, rows){
    const n = cols*rows;
    const order = Array.from({length:n}, (_,i)=>i);
    const p = prng(SEED ^ cols ^ (rows<<16));
    // Fisher-Yates
    for (let i=n-1;i>0;i--){ const r = p.next().value % (i+1); const t=order[i]; order[i]=order[r]; order[r]=t; }
    // Orientation per tile: 0,1,2,3 = rotate 0,90,180,270
    const rot = new Uint8Array(n);
    for (let i=0;i<n;i++) rot[i] = (p.next().value >>> 0) & 3;
    return { order, rot };
  }

  // Helpers
  const $ = sel => document.querySelector(sel);
  const canvas = $('#canvas');
  const ctx = canvas.getContext('2d', { willReadFrequently:true });
  const work = document.createElement('canvas');
  const wctx = work.getContext('2d', { willReadFrequently:true });

  const input = $('#file');
  const status = $('#status');
  const dim = $('#dim');
  const toastEl = $('#toast');
  const viewer = document.querySelector('.viewer');
  const normalizeChk = $('#normalize');

  const btnUpload = $('#btnUpload');
  const btnEncode = $('#btnEncode');
  const btnDecode = $('#btnDecode');
  const btnShare  = $('#btnShare');
  const btnReset  = $('#btnReset');
  const btnTests  = $('#btnTests');

  let hasImage=false, encoded=false; let naturalW=0, naturalH=0; let cols=0, rows=0; let plan=null;

  function showToast(t){ toastEl.textContent=t; toastEl.classList.add('show'); clearTimeout(showToast._t); showToast._t=setTimeout(()=>toastEl.classList.remove('show'),1600); }
  function setStatus(t){ status.textContent=t; }

  function fitToCanvas(w,h){
    const maxW = Math.min(viewer.clientWidth-2, 4096);
    const maxH = Math.min(Math.max(window.innerHeight*0.62, 280), 4096);
    const s = Math.min(maxW/w, maxH/h, 1);
    const cw = Math.max(1, Math.round(w*s));
    const ch = Math.max(1, Math.round(h*s));
    canvas.style.width=cw+'px'; canvas.style.height=ch+'px'; canvas.width=cw; canvas.height=ch; ctx.setTransform(1,0,0,1,0,0);
  }
  function redraw(){ fitToCanvas(naturalW,naturalH); ctx.clearRect(0,0,canvas.width,canvas.height); ctx.drawImage(work,0,0,canvas.width,canvas.height); }

  function normalizeImage(bmp){
    let w=bmp.width||bmp.naturalWidth, h=bmp.height||bmp.naturalHeight;
    const scale = Math.min(1, LONG_EDGE/Math.max(w,h)); // downscale only
    const w1 = Math.round(w*scale), h1=Math.round(h*scale);
    // Quantize to TILE by center-cropping
    const wT = Math.max(TILE, Math.floor(w1/TILE)*TILE);
    const hT = Math.max(TILE, Math.floor(h1/TILE)*TILE);
    const tmp = document.createElement('canvas'); tmp.width=w1; tmp.height=h1; const tx=tmp.getContext('2d');
    tx.drawImage(bmp, 0,0,w1,h1);
    const sx = Math.floor((w1 - wT)/2), sy=Math.floor((h1 - hT)/2);
    work.width=wT; work.height=hT; wctx.clearRect(0,0,wT,hT);
    wctx.drawImage(tmp, sx, sy, wT, hT, 0,0, wT, hT);
    naturalW=wT; naturalH=hT; cols=Math.floor(naturalW/TILE); rows=Math.floor(naturalH/TILE);
  }
  function loadExact(bmp){
    // No normalization; just crop to TILE grid (center)
    let w=bmp.width||bmp.naturalWidth, h=bmp.height||bmp.naturalHeight;
    const wT=Math.max(TILE, Math.floor(w/TILE)*TILE); const hT=Math.max(TILE, Math.floor(h/TILE)*TILE);
    const sx=Math.floor((w-wT)/2), sy=Math.floor((h-hT)/2);
    work.width=wT; work.height=hT; wctx.clearRect(0,0,wT,hT); wctx.drawImage(bmp, sx,sy,wT,hT, 0,0,wT,hT);
    naturalW=wT; naturalH=hT; cols=Math.floor(naturalW/TILE); rows=Math.floor(naturalH/TILE);
  }

  function drawTile(srcX,srcY, dstX,dstY, rot){
    const s=TILE;
    wctx.save();
    // Move to dest tile origin
    wctx.translate(dstX+s/2, dstY+s/2);
    wctx.rotate((rot%4)*Math.PI/2);
    // After rotation, the source draw needs to be centered; rotate affects axes
    wctx.drawImage(work._src, srcX, srcY, s, s, -s/2, -s/2, s, s);
    wctx.restore();
  }

  function encodeTiles(){
    // Copy source to an auxiliary canvas for reads
    const src=document.createElement('canvas'); src.width=naturalW; src.height=naturalH; src.getContext('2d').drawImage(work,0,0);
    work._src = src; // attach for drawTile

    // Create fresh destination
    const out=document.createElement('canvas'); out.width=naturalW; out.height=naturalH; const ox=out.getContext('2d');

    plan = makePlan(cols, rows);
    const n=cols*rows; const s=TILE;
    for (let idx=0; idx<n; idx++){
      const srcIdx = idx;                 // source tile index in row-major
      const dstIdx = plan.order[idx];     // where it should land
      const r = plan.rot[idx];
      const sx = (srcIdx % cols) * s; const sy = Math.floor(srcIdx/cols) * s;
      const dx = (dstIdx % cols) * s; const dy = Math.floor(dstIdx/cols) * s;
      // draw src tile rotated into out at (dx,dy)
      ox.save();
      ox.translate(dx+s/2, dy+s/2);
      ox.rotate((r%4)*Math.PI/2);
      ox.drawImage(src, sx, sy, s, s, -s/2, -s/2, s, s);
      ox.restore();
    }

    // Replace work with out
    wctx.clearRect(0,0,naturalW,naturalH);
    wctx.drawImage(out,0,0);
    encoded=true; setStatus('Image encoded (tile shuffle)'); redraw();
  }

  function decodeTiles(){
    if (!plan){ plan = makePlan(cols, rows); }
    const src=document.createElement('canvas'); src.width=naturalW; src.height=naturalH; src.getContext('2d').drawImage(work,0,0);
    const out=document.createElement('canvas'); out.width=naturalW; out.height=naturalH; const ox=out.getContext('2d');

    const n=cols*rows; const s=TILE;
    for (let idx=0; idx<n; idx++){
      const srcIdx = plan.order[idx]; // encoded tile position
      const dstIdx = idx;             // original position
      const r = (4 - (plan.rot[idx]%4)) % 4; // inverse rotation
      const sx = (srcIdx % cols) * s; const sy = Math.floor(srcIdx/cols) * s;
      const dx = (dstIdx % cols) * s; const dy = Math.floor(dstIdx/cols) * s;
      ox.save();
      ox.translate(dx+s/2, dy+s/2);
      ox.rotate(r*Math.PI/2);
      ox.drawImage(src, sx, sy, s, s, -s/2, -s/2, s, s);
      ox.restore();
    }

    wctx.clearRect(0,0,naturalW,naturalH);
    wctx.drawImage(out,0,0);
    encoded=false; setStatus('Image decoded (tiles restored)'); redraw();
  }

  async function drawBitmap(bmp){
    if (normalizeChk.checked) normalizeImage(bmp); else loadExact(bmp);
    dim.textContent = `${naturalW}×${naturalH}px | ${cols}×${rows} tiles`;
    hasImage = true; encoded=false; redraw();
    const ph = document.getElementById('placeholder'); if (ph) ph.style.display='none';
    updateButtons();
  }

  async function loadFile(file){
    if (!file) return;
    try{
      const url = URL.createObjectURL(file);
      const bmp = await (window.createImageBitmap ? createImageBitmap(file) : new Promise((res,rej)=>{const img=new Image(); img.onload=()=>res(img); img.onerror=rej; img.src=url;}));
      URL.revokeObjectURL(url);
      await drawBitmap(bmp);
      setStatus(`Loaded: ${file.name}`);
    }catch(err){ console.error(err); showToast('Failed to load image'); }
  }

  function updateButtons(){
    btnEncode.disabled = !hasImage;
    btnDecode.disabled = !hasImage;
    btnShare.disabled  = !hasImage;
    btnReset.disabled  = !hasImage;
    const ph = document.getElementById('placeholder'); if (ph) ph.style.display = hasImage ? 'none' : 'flex';
  }

  // --- Share as normal photo (JPEG) ---
  async function shareNow(){
    if (!hasImage){ showToast('Nothing to share'); return; }
    // Export as JPEG (WhatsApp will re-JPEG but keep size)
    work.toBlob(async blob=>{
      const file = new File([blob], encoded ? 'tile-encoded.jpg' : 'tile.jpg', { type:'image/jpeg' });
      try{
        if (navigator.share && navigator.canShare && navigator.canShare({ files:[file] })){
          await navigator.share({ files:[file], title:'TilePad', text: encoded ? 'Tile-encoded image' : 'Image' });
        }else{
          const url = URL.createObjectURL(blob); const a=document.createElement('a'); a.href=url; a.download=file.name; a.click(); setTimeout(()=>URL.revokeObjectURL(url),800); showToast('Downloaded JPEG');
        }
      }catch(e){ console.error(e); showToast('Share failed'); }
    }, 'image/jpeg', 0.92);
  }

  // --- Reset & listeners ---
  function resetAll(){
    if (!hasImage){ setStatus('No image loaded'); return; }
    wctx.clearRect(0,0,work.width,work.height); ctx.clearRect(0,0,canvas.width,canvas.height);
    hasImage=false; encoded=false; naturalW=naturalH=cols=rows=0; plan=null; dim.textContent='–'; updateButtons(); setStatus('Reset complete');
    const ph = document.getElementById('placeholder'); if (ph) ph.style.display='flex';
  }

  btnUpload.addEventListener('click', ()=> input.click());
  input.addEventListener('change', e=>{ loadFile(e.target.files[0]); });
  btnEncode.addEventListener('click', ()=>{ if(!hasImage) return; encodeTiles(); updateButtons(); });
  btnDecode.addEventListener('click', ()=>{ if(!hasImage) return; decodeTiles(); updateButtons(); });
  btnShare .addEventListener('click', shareNow);
  btnReset .addEventListener('click', resetAll);
  window.addEventListener('resize', ()=>{ if(hasImage) redraw(); });

  // --- Self tests ---
  function arraysEqual(a,b){ if(a.length!==b.length) return false; for(let i=0;i<a.length;i++){ if(a[i]!==b[i]) return false; } return true; }
  function testRoundTrip(){
    const w=256,h=192; const c=document.createElement('canvas'); c.width=w; c.height=h; const x=c.getContext('2d');
    // Draw pattern
    const img=x.createImageData(w,h);
    for(let y=0;y<h;y++) for(let q=0;q<w;q++){ const i=(y*w+q)*4; img.data[i]=q%256; img.data[i+1]=y%256; img.data[i+2]=(q^y)%256; img.data[i+3]=255; }
    x.putImageData(img,0,0);

    // Load into app pipeline
    loadExact(c); const before=wctx.getImageData(0,0,work.width,work.height);
    encodeTiles(); decodeTiles();
    const after=wctx.getImageData(0,0,work.width,work.height);
    return arraysEqual(before.data, after.data);
  }
  btnTests.addEventListener('click', ()=>{
    const ok = testRoundTrip();
    alert((ok?'✅':'❌') + ' Round-trip encode/decode ' + (ok?'passed':'failed'));
  });

  // Init
  updateButtons();
})();
</script>
</body>
</html>
